# Security

Security consists of two parts:

- authentication: who is connecting
- authorization: what can they do

This can be managed locally or remotely.

## Local Connection

A listener is added to port 5122 (triton.local.port=5122) which allows for direct access through either the console or telnet. This connection is not secured and only connections made from local addresses are accepted. 

Whoever connects to this port is considered to be an admin as they have access to the machine itself. It is advised to use SSH or something to access Triton over this port.

Example of a connection url for the console: ``ts://localhost:5122``
Example of a telnet connection:

```
$ telnet localhost 5122
```

You can disable the local port by setting the parameter ``triton.local.enabled=false`` when starting triton.

The local connection can be used to do initial setup of the machine and/or as the only point of access if layered over something like SSH.

By default the triton console will try to connect to ``ts://localhost`` which is the unsecure connection.
You can connect to a different host using the parameter ``triton.host`` or simply ``host``.

Note that if you fill in a host without specifying the scheme, triton will assume you want sts seeing as ts is only available to localhost.

## SSL

Note that certificates are used for both server and client authentication. The CN field is considered to be the identity while the certificate itself is the authentication.

Example of a connection url for the console: ``sts://localhost``.
You may be able to still connect to the secure endpoint using for example the openssl toolset but because client certificates are mandatory this might be slightly harder to set up.

### Server side

On port 5123 (triton.secure.port=5123) triton will start an SSL-secured equivalent of the other port, meaning that, once connected it behaves exactly the same but it is secured by SSL.

Unless centrally managed, every Triton server will generate a self signed certificate which will be used as its identity.
When users connect to this machine for the first time, they will be asked if they want to accept the certificate.

You can centralize the creation of the certificates with a central authority which means you can configure clients to automatically accept the certificates, this creates an additional layer of trust that is highly advised in enterprise setups.

### Client side

The Triton server will expect a client side certificate which authenticates the user. There is (currently) no username/password equivalent.

The client can have multiple identities, which is to say multiple certificates. When starting up the console the user can choose which identity to use to connect to a particular Triton server.

The certificates that the client has can be either self-signed or generated by a central entity.

If generated by a central entity, the root certificate can be installed on the triton server, allowing anyone that has a correctly signed certificate with no further action being taken. Note that this is only the "authentication" part, what you can do once you connect (if anything) is part of the authorization.

If the certificate is self signed, it has to be installed on the Triton server to allow access. This can be done by someone who already has access (and the correct authorization) or this can be done using the local access on port 5000.

#### You install it

Connect with your console to the local admin connection (e.g. layered over SSH).

Type ``allow``.

The console will at that point install the certificate of the current identity in the server it is connected to.

#### Someone else installs it

If someone else installs the certificate, these steps should be performed:

- the client who wants access starts up the console and types ``self``. This will output his certificate which he must give to the person who can access the machine
- the other person access the Triton instance and types this:

```
allow("<paste certificate here>")
```

Note that by default the certificate output is a multiline, you should add one tab to the entire content before pasting it in the console to get a correct multiline statement.

When a new certificate is added, the 5123 port will go offline temporarily and be restarted with the new SSL context, this is currently a limitation of how it is set up.

## Something you know

To add to the "something you have" (the certs), you can also add "something you know".
This is not enforced by the Triton server, instead it is the password that is used to securely store your certificate, meaning it is entirely handled by the client.

## Profiles

You can use multiple profiles for your triton installation, this is mostly interesting when using the triton client though it can also be used on the triton server.

The default profile is "triton-client" or "triton-server" depending on the mode. You can configure ``triton.profile`` or simply ``profile`` to choose a given profile.
Each profile has its own public/private key meaning you can switch between identities by choosing a different profile.

If there is no key yet for a given profile, one will be generated for your with a self signed certificate, you can manage the settings used in that certificate:

- triton.name: the CN of the certificate, this defaults to the name of your computer unless specified otherwise
- triton.organisation
- triton.organisationalUnit
- triton.locality
- triton.state
- triton.country

# Folder Layout

Triton needs a number of folders to operate, if you configure nothing, the defaults will be used.
The defaults are the triton client are located in a hidden folder ``.triton-client`` which resides in your home folder whereas the default for the server is ``.triton-server``.

## Configuration

Triton needs a configuration folder where it stores things like the keystore.
This can be configured using ``triton.folder.config`` and defaults to the root of the hidden folder.

## Scripts

Triton needs a folder to store and use glue scripts. This can be configured by setting ``triton.folder.scripts``.
It defaults to a subfolder "scripts" of the hidden folder.

# Packaging

Packaging has two variants: secure and unsecure.
Both behave exactly the same way except for the secure setup every package must be signed by a trusted authority.

The basic distributable is a zip. Inside that zip must be at least one folder, the name of the folder must match a folder configured in the folder layout.
For example if you want to distribute scripts, the zip file should have a root folder "scripts" and inside it, the actual scripts.
You can have multiple root folders that are installed to their relative locations.

Each zip file should contain a ``manifest.tr`` file.
The manifest is a key/value pair list structured like this:

```
key=value
key=value
```

There are two mandatory descriptive fields:

```
module=<module>
version=<version>
```

The module name must contain only lowercased letters and dashes.
The version must adhere to this format:

```
major.minor.patch
```

This can be for example "1.0.1".

The zip must also contain a file ``author.crt`` which is the certificate of the author. The CN of the author is considered to be the name of the author.
Note that the certificate must be trusted by the triton server, either by installing it manually or by installing a trusted root certificate.


# Name

Triton is the messenger of the sea god Poseidon.
Interestingly, it can be multiplied into "tritones".

# Goal

Triton is a standalone component that can be run on a machine. It will connect to a central instance (referred to as Poseidon) and get instructions to run on the local machine. The connection uses websockets for full duplex communication over a persistent connection while reusing the firewall friendly http protocol.

Triton will have three main responsibilities:

- System health
	- triton will use a heartbeat to send system information (disk space usage, cpu usage, memory usage...)
	- the persistance of the connection and the heartbeat combine to make it easy to figure out if a system is down, poseidon can use this
- Remote management
	- triton allows management of arbitrary glue files to be pushed from poseidon
	- this allows you to do all sorts of management automation like
		- installation of software
		- software updates
		- ssh key management
		- ssh tunneling
		- restarting of services
		...
- CEF Events: triton will allow pushing 

# Offline

Ideally triton can still be used without poseidon, through a local interface. This would allow it to retain some of its features in environments where the central hookup is not allowed.
We could set up a local socket (can only be connected to from localhost, ssh inbound is seen as localhost) that allows you to send commands?
The local socket requirement prevents the need for identification.

# Identifier

Each triton client connects with an identifier to the central instance.
This identifier can be provided or it can be generated. The identifier is generally a very long randomly generated value, comparable to an API key.
The central instance can use this identifier to assign attributes to this instance (e.g. a name, a script repository,...)

It is possible for multiple triton clients to connect with the same identifier, this is especially relevant when dealing with auto-scaling clusters.

# Clustering

Triton clients are _not_ cluster-aware but they can share an identifier to get identical settings.

# Security

It is advised to layer triton communication over https to encrypt traffic though http is also supported.
There is no additional security in the form of username and passwords, the identifier acts as an API key.

Note that poseidon can (and should) reject connections from API keys that are not registered centrally.
Triton will retry connecting from time to time in case of rejection, assuming the system administrator still has to get around to registering the API key.

# Format

Triton exclusively uses "triton messages" to communicate, each triton message has these fields:

- type: the type of message
- version: the version of the type (defaults to 1)
- payload: the content of the message
- id: the unique id for this message
- conversationId: the first message in a conversation will have a conversation id that is identical to the id, subsequent messages sent as part of the same conversation have the original conversation id

The messages are serialized as XML before they are sent to poseidon over the websocket connection.

Based on the type, poseidon can decide where it has to go. The payload usually contains structured XML or JSON data but it is optional and can be left out completely. In general we prefer JSON to minimize the need for encoding for XML-in-XML.
If a binary payload is required, it must be base64 encoded and stored in the payload as a string.

# Encoding

Triton uses UTF-8 encoding by default.

# Plugins

The triton core is mostly interested in maintaining the connection to the server and allow dissemination of commands while allowing system commands to be run. Everything else is distributed in plugins.

Planned plugins:

- glue runner: allow synchronization & running of glue scripts and commands
- health check: send information about the server health